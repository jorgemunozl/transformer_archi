\documentclass[twocolumn]{article}

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{xcolor}         % colors
\usepackage{amsmath}
\usepackage{natbib}
\usepackage{authblk}
\usepackage{hyperref}
\usepackage{cleveref}   % smart refs: \cref
\usepackage[
  a4paper,
  left=2cm,
  right=2cm,
  top=2cm,
  bottom=2cm
]{geometry}
\usepackage{braket}
\usepackage{graphicx}
\title{Development of a Transformed based architecture to solve the Time Independent Schrodinger Equation for many bodies}
\author[1]{Jorge Alvaro Munoz Laredo}
\affil[1]{Faculty of Physics, Universidad Nacional de Ingeniería, Lima, Peru\\
\texttt{jorge.munoz.l@uni.pe}
}

\begin{document}

\twocolumn[
\begin{@twocolumnfalse}
  \maketitle

  \begin{abstract}
With accurate solutions to the many-electron Schrodinger equation all
the chemistry could be derived from first principles, but analytical treatment is intractable due the intrinsic strong electron-electron correlations, anti symmetry and cusp behavior. Recently, due to its high flexibility deep learning approaches had been applied for this problem, neural wave functions models such as FermiNet and PauliNet have advanced accuracy, yet computational cost and error typically grows steeply with system size, limiting applicability to
larger molecules. They also lack of strong architectures designed to
capture long-range electronic correlations with scalable attention. In
this work I develop the Psiformer a transformer-based ansatz that
couples scalable attention with physics-aware structure. Training is
formulated within Variational Monte Carlo (VMC), evaluation will be do
it by comparing ground state energy against another traditional methods, I also outline design questions for further improvement, including sparsified/global
attention and optimizer choices inspired by recent transformer advances.
\end{abstract}

\vspace{1em} % a bit of vertical space before the columns start
\end{@twocolumnfalse}
]

\section{Introduction}
The electronic structure problem remains challenging: the wave functions which fully describes the system lives in a \(3N\)-dimensional space,\(N\) the number of electrons, each one lives on the 3 dimensional space.
Additionally, it must satisfy specific properties due to physical laws and live on the complex space.

Although the governing laws have been known for almost a century \cite{Schrodinger1926_undulatory}, obtaining practical approximations to the quantum many-body wavefunction remains difficult. Established approaches such as density-functional theory \cite{KohnSham1965}, Born Oppenheimer \cite{BornOppenheimer1927}, and structured variational ansätze \cite{McMillan1965GroundStateHe4} trade generality for tractability by
imposing specific functional forms or approximations to correlation.
These choices are effective within their regimes but can struggle for strongly correlated systems or scale poorly with electron count cite. This is where modern learning-based methods enter: instead of fixing the functional form, we learn it, while enforcing essential physics (antisymmetry, cusp behavior, permutation symmetry), here is where deep learning methods shines. This field has reshaped several scientific domains, from protein structure prediction \cite{jumper2021highly} to vision modeling \cite{dosovitskiy2021imageworth16x16words} and PDE surrogates \cite{RAISSI2019686}.
Motivated by these successes, the community has explored neural approaches for quantum many-body problems ,seeking accurate and scalable approximations to the many-electron wavefunction \cite{Luo_2019,Qiao_2020}.

Thus, neural wavefunction models have emerged as a promising alternative. Architectures such as \textbf{FermiNet} \cite{Pfau_2020} and \textbf{PauliNet} \cite{Hermann_2020} combine flexible function approximators with determinant structures to respect antisymmetry, improving variational expressivity. However, two practical limitations persist. First, error or compute cost often scales unfavorably with the number of electrons, restricting applicability to
larger molecules. Second, mechanisms for \textbf{long-range electronic
correlation} central to Coulomb and exchange effects are typically implicit or expensive to capture, leading to optimization difficulty and
brittle generalization.

Transformers offer an appealing direction. Self-attention provides
direct, many-to-many interactions among tokens in a single layer, is highly parallelizable, and has empirically favorable scaling behavior in other domains (Natural Language Processing \cite{Vaswani2017}. For electronic structure, where any electron can interact with any other and electron indices are exchangeable, attention aligns naturally with the physics: it enables global coupling without imposing an arbitrary ordering. The challenge is
to embed the right \textbf{inductive biases} (distance awareness, spin structure, cusp handling) and to maintain \textbf{fermionic antisymmetry} while keeping computational cost under control.

I develop \textbf{Psiformer}, a transformer-based variational ansatz for
many-electron systems \cite{vonglehn2023selfattentionansatzabinitioquantum}. Psiformer uses self-attention to construct rich
per-electron features informed by electron--electron and
electron--nucleus descriptors, then imposes antisymmetry explicitly via
determinant-based heads. Physics-aware priors (e.g., distance/radial
encodings and cusp-motivated embeddings) are incorporated to reduce
sample complexity and stabilize training. The optimization is formulated within \textbf{Variational Monte Carlo (VMC)} \cite{McMillan1965GroundStateHe4} by minimizing the variational energy.

\textbf{Contributions.}

\begin{itemize}
    \item A transformer-based neural wavefunction (\textbf{Psiformer}) \cite{vonglehn2023selfattentionansatzabinitioquantum} implemented on Pytorch \cite{Paszke2019PyTorch} that separates correlation modeling (attention) from fermionic symmetry (determinant heads) while embedding Coulomb-aware priors.
    \item A VMC training recipe with practical choices for stability (feature design, and optional natural-gradient preconditioning).
\end{itemize}

The objectives are the follow:

\section{Objectives}
\begin{itemize}
\item
  Obtain a model which is able to approximate the ground state energy for specific atoms and molecules.
\item
  Compare our model against other state of the art methods to solve the many electrons Schrodinger equation.
\item
  Look for future improvements when try to tackle larger molecules.
\end{itemize}

\section{Overview}

This work is structured as follow: The theoretical framework \cref{sec:theo} introduces the foundations of quantum many-body theory, the structure of the
Schrodinger equation for many-bodies like also foundational concepts of
Deep Learning that are going to be used in the development of this
specific problem, \cref{psi-former-model}  introduce \textbf{Psi Former} a transformer based architecture built upon \textbf{Fermi Net}, \cref{methodology} specify the specific tools and environments used to implement this work.

\section{Theoretical Framework}\label{sec:theo}

In this section, we develop the physical and mathematical foundation needed to understand the problem we study. We begin with the Schrödinger wave equation, which is central to non-relativistic quantum mechanics.
\subsection{The wave function and the governing physical laws}

\subsubsection{The Schrodinger Equation}

The Schrodinger equation was presented in a series of publications made
it by Erwin Schrodinger in the year 1926 \cite{Schrodinger1926_undulatory}. There we search the complex
function \(\psi\) which lives on a Hilbert space \(\mathcal{H}\) called
\textbf{wave function}, for a non relativistic spinless single particle
this function depends on the position of the particle
\(\mathbf{\vec{r}}\) and time \(t\) \((\psi(\mathbf{\vec{r}},t))\), the
quantity \(\lvert \psi (\mathbf{r},t)\rvert^{2}\) is the
\textbf{probability density} to find the particle near \(\mathbf{r}\) at
time \(t\) \cite{Bohr1928Nature}.

Guided by de Broglie's discover \cite{deBroglie1924thesis} of the wave particle duality and a very smart intuition Schrodinger proposed the time dependent equation (TDSE):

\begin{equation}
i\hbar \frac{\partial \psi}{\partial t}=\hat{H}\psi
 \label{tise}
\end{equation}

Where \(i\) is the complex unit, \(\hbar\) is the reduced Planck constant  approximate to \(1.054571817\dots \times 10^{-34} J\cdot s\) and \(\hat{H}\) is a hermitian linear operator called the \textbf{Hamiltonian} which represents the total energy of the system,
for a single non relativistic (low energy) particle of mass \(m\) in a scalar potential \(V(\mathbf{r},t)\), it takes the form:

\begin{equation}
\hat{H}=\frac{\hat{\mathbf{p}}^{2}}{2m}+V(\mathbf{r},t)
  \label{eq:hamil}
\end{equation}

Where \(\mathbf{\hat{p}}\) is the momentum operator and in the \textbf{position representation} it takes the form of \cite{Zettili2009}:

\begin{equation}
\mathbf{\hat{p}}=-i\hbar \nabla
  \label{p}
\end{equation}
Where \(\nabla\) is the Laplacian operator, thus the TDSE is
explicitly:

\begin{equation}
 i\hbar\,\frac{\partial \psi}{\partial t} = \left[-\frac{\hbar^{2}}{2m}\nabla^{2}+V(\mathbf r,t)\right]\psi
  \label{eq:ex}
\end{equation}

The \textbf{time independent form} (TISE) could be derived from equation ,when the wave function \(\psi\) could be written like the
product of two functions \(R\) and \(T\), where \(R\) depends uniquely
on the spatial term \((\mathbf{{r}})\) and \(T\) uniquely on the temporal \((t)\), this is:

\begin{figure*}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{img/ferminet.png}
    \caption{FermiNet have two streams, acting on electron-nuclear and electron-electron features which are merged via concatenation, image source from \cite{vonglehn2023selfattentionansatzabinitioquantum}}
    \label{fig:fermi}
\end{figure*}

\begin{equation}
\psi(\mathbf{{r}},t)=R(\mathbf{{r}})T(t)
\end{equation}

Plugin this form on equation \ref{tise}, you can derive that \cite{Zettili2009}:
\[
T(t)=e^{ -iEt/\hbar }
\] Where \(E\), the energy of the system, is a constant. You also obtain that the spatial part is conditioned by:

\begin{equation}
\hat{H}R(\mathbf{{r}})=ER(\mathbf{{r}})
  \label{eq:}
\end{equation}

 We are going to represent the spatial function \(R\) as \(\psi\). And
in this work we are going to only focus in the TDSE, when we treat with
constant energy, the electron are almost always found near the lowest
energy state, known as the ground state. Solutions with higher energy known as excited states are relevant to photochemistry , but in this work we will restrict our attention to ground states. \subsubsection{The many electron Schrodinger Equation}

When we are considering more than one single particle we consider the spin \((\sigma)\) and the interaction between particles. Thus, in its time-independent form the Schrodinger equation can be written as an eigen value problem:

\begin{equation}
\hat{H}\psi(\mathbf{x}_{0},\dots ,\mathbf{x}_{n})=E\psi(\mathbf{x}_{1},\dots ,\mathbf{x}_{n})
  \label{eq:tilin}
\end{equation}
Where \(\mathbf{x}_{i}=\{ \mathbf{r}_{i},\sigma \}\), \(\mathbf{r}_{i}\in \mathbb{R}^{3}\) is the position of each electron
and \(\sigma \in \{ \uparrow.\downarrow \}\) is the so called spin. It's
possible model the potential energy of a many body system (e.g atoms,
molecules), we first have to consider the potential given the repulsion between electrons:
\begin{equation}
V_{ij} = \frac{e^{2}}{4\pi\varepsilon_{0}} \frac{1}{\lvert \mathbf{r}_{i}-\mathbf{r}_{j} \rvert}
  \label{eq:}
\end{equation}

Here \(e = 1.602\,176\,634\times 10^{-19}\ \mathrm{C}\) is the elementary charge, \(\varepsilon_{0} = 8.854\,187\,8128\times 10^{-12}\ \mathrm{F\,m^{-1}}\) is the electrical permittivity of vacuum, $\mathbf{r}_i$ is the position vector of electron \(i\) in the chosen reference frame. The potential given the attraction between the proton $I$ and the electron $i$ is given by:
\begin{equation}
V_{iI} = -\frac{1}{4\pi\varepsilon_{0}} \frac{eZ_{I}}{\lvert \mathbf{r}_{i} - \mathbf{R}_{I} \rvert}
  \label{eq:asd}
\end{equation}
Where \(Z_I\) is the atomic number of nucleus \(I\) (for instance, in
a Helium atom \(Z = 2\)) and \(\mathbf{R}_I\) is the position of that
nucleus from a chosen reference frame.\\
The reference frame is usually taken at the \textbf{center of mass} or
at the \textbf{center of the molecule}. The potential given the repulsion between the nuclei
\(I\) and \(J\) (protons) is:

\begin{equation}
V_{IJ} = \frac{1}{4\pi\varepsilon_{0}} \frac{Z_{I}Z_{J}}{\lvert \mathbf{R}_{I} - \mathbf{R}_{J} \rvert}
  \label{eq:sdasd}
\end{equation}

To avoid writing these constants every time, quantum chemistry commonly uses \textbf{atomic units (a.u.)}. In this system, the unit of length is the \textbf{Bohr radius} \(a_{0}\),\\
and the unit of energy is the \textbf{Hartree} \(E_{h}\) \cite{IUPAC_GoldBook_AtomicUnits}:

\begin{equation}
E_{h} = \frac{e^{2}}{4\pi\varepsilon_{0} a_{0}}
  \label{eq:so slightl}
\end{equation}

Under atomic units, \(e = 1\),
\(4\pi\varepsilon_{0} = 1\),\(\hbar = 1\), and \(m_{e} = 1\) .
Thus, the potential energy of a system with \(N_{e}\) electron and
\(N_{n}\) nucleus can be written compactly as:
\begin{equation}
  V = -\sum_{i=1}^{N_{e}}\sum_{I=1}^{N_{n}}  \frac{Z_I}{\lvert \mathbf{r}_i - \mathbf{R}_I \rvert} + \sum_{i>j} \frac{1}{\lvert \mathbf{r}_i - \mathbf{r}_j \rvert} + \sum_{I>J} \frac{Z_I Z_J}{\lvert \mathbf{R}_I - \mathbf{R}_J \rvert}
\end{equation}

where \(i, j\) are index electrons, \(I, J\) are index nuclei.The first term represents \textbf{electron--nucleus attraction}, the second term is \textbf{electron--electron repulsion}, the third term is \textbf{nucleus--nucleus repulsion}.
For the kinetic term on the Hamiltonian we need to
consider two expressions: \(\nabla_i^2\) acts on the \textbf{electron} coordinates \(\mathbf r_i\) (fast, light particles) and \(\nabla_I^2\)
acts on the \textbf{nuclear} coordinates \(\mathbf R_I\) (slow, heavy
particles). Let \(N\) electrons at \(\mathbf r_i\) and \(M\) nucleous at
\(\mathbf R_I\) with charges \(Z_I\) and masses \(M_I\) (in units of
\(m_e\)) then the \textbf{Hamiltonian} can be written as:
\begin{align}
\hat H &= -\sum_{i=1}^{N}\frac{1}{2}\nabla_i^{2} -\sum_{I=1}^{M}\frac{1}{2M_I}\nabla_{I}^{2} -\sum_{i=1}^{N}\sum_{I=1}^{M}\frac{Z_I}{|\mathbf r_i-\mathbf R_I|} \notag\\
+&\sum_{1\le i<j\le N}\frac{1}{|\mathbf r_i-\mathbf r_j|}+\sum_{1\le I<J\le M}\frac{Z_I Z_J}{|\mathbf R_I-\mathbf R_J|}
\end{align}

\subsubsection{Conditions of the solution}

As with any differential equation, where one is searching one solution, is important to consider initial conditions (IC) and boundary conditions (BC), here we have to fulfill certain conditions that comes from physical laws.


At the microscopic level particles are indistinguishable, any measurement cannot distinguish between electron one and electron two. Therefore swapping the labels of two particles must leave all measurable  predictions unchanged.

Quantum theory \cite{Zettili2009} show that particles are or bosons (e.g., photons) that follows the \textbf{Bose--Einstein} statistics \cite{Bose1924, Einstein1924Gas} or fermions (e.g., electrons, protons) that follow \textbf{Fermi Dirac} statistics \cite{Fermi1926Quantelung, Dirac1926TheoryQM}, an important consequence of the second is the antisymmetry on the wave function.

If we plug the same coordinates $x_1=x_2$ (meaning same position and same spin coordinate).

\begin{equation}
\psi(x,x)=−\psi(x,x) \implies \psi(x,x)=0
\end{equation}

So two fermions cannot occupy the same one-particle quantum state. That’s the Pauli exclusion principle \cite{Pauli1925Exclusion}, being more general:
\begin{equation}
\psi(\dots,\mathbf{x}_{i},\dots,\mathbf{x}_{j},\dots)=-\psi(\dots ,\mathbf{x}_{j},\dots ,\mathbf{x}_{i},\dots)
\label{eq:every}
\end{equation}

We can enforce \textbf{antisymmetry} using a \(N\times N\)
Slater determinant \cite{Slater1929TheoryComplexSpectra}, which involves one-particle states only (a wave function
with a single input) . An interchange of any pair of particles
corresponds to an interchange of two columns of the determinant; this
interchange introduces a change in the sign of the determinant. For even
permutations we have \((-1)^{P}=1\), and for odd permutations we have \((-1)^{P}=-1\).

\begin{equation}
\Psi(\mathbf x_1,\ldots,\mathbf x_N)
\propto
\begin{vmatrix}
\phi_1(\mathbf x_1) & \phi_2(\mathbf x_1) & \cdots & \phi_N(\mathbf x_1)\\
\phi_1(\mathbf x_2) & \phi_2(\mathbf x_2) & \cdots & \phi_N(\mathbf x_2)\\
\vdots & \vdots & \ddots & \vdots\\
\phi_1(\mathbf x_N) & \phi_2(\mathbf x_N) & \cdots & \phi_N(\mathbf x_N)
\end{vmatrix}
\end{equation}
Where \(\phi_k\) are orthonormal (by construction) spin orbitals. This is, for instance
\((N=2)\):
\begin{equation}
\Psi(\mathbf x_1,\mathbf x_2) \propto\Big[\phi_a(\mathbf x_1)\phi_b(\mathbf x_2)-\phi_a(\mathbf x_2)\phi_b(\mathbf x_1)\Big].
  \label{eq:sdg}
\end{equation}

The potential energy becomes infinite, when two particles overlap, which
places strict constraints on the form of the wave function at these
points, these constraints are known as the \textbf{Kato Cusp Conditions} \cite{Kato1957EigenfunctionsManyParticle}. The cusp conditions states that the wave function must be non-differentiable at these points, and give exact values for the average derivatives at the cusps. More precisely the cusp result of the Kato Theorem are:
Electron-nucleus cusp (electron with charge
\(-1\), nucleus charge \(+Z\), reduced mass \(\mu \approx 1\))


\begin{equation}
\lim_{ riI \to 0 } \left( \frac{\partial \psi}{\partial r_{iI}} \right)=-Z\psi(r_{iI}=0)
\end{equation}


Electron-electron cusp, opposite spins (charges \(-1\), reduced
mass \(\mu=\frac{1}{2}\))

\begin{equation}
\lim_{ r_{ij}\to 0 } \left( \frac{\partial \psi}{\partial r_{ij}} \right)=\frac{1}{2}\psi(r_{ij}=0)
\end{equation}

Where \(r_{iI}(r_{ij})\) is an electron-nuclear (electron-electron)
distance, \(Z_{I}\) is the nuclear charge of the \(I\text{-th}\)
nucleous and ave implies a spherical averaging over all directions.

This conditions can be obtained if we multiply to the ansatz by multiplying by a Jastrow factor \(\mathcal{J}\)which satisfies these conditions analytically \cite{Jastrow1955ManyBodyProblem}.

So that is the problem we need to find a \(\psi\) such that it satisfies all those conditions.

\subsubsection{Approximations to the problem}

Is clear that find analytical solutions is practically impossible, so what people have been doing is first apply good approximations.
\textbf{Born Oppenheimer approximation} \cite{BornOppenheimer1927} makes it possible to separate the motion of the nuclei and the motion of the electrons, neglects the
motion of the atomic nuclei when describing the electrons in a molecule.
The physical basis for the Born-Oppenheimer approximation is the fact
that the mass of an atomic nucleus in a molecule is much larger than the
mass of an electron (more than 1000 times) \cite{PDG2024}. Because of this difference,
the nuclei move much more slowly than the electrons. In addition, due to
their opposite charges, there is a mutual attractive force of: acting on
an atomic nucleus and an electron. This force causes both particles to
be accelerated. Since the magnitude of the acceleration is inversely
proportional to the mass, \(a = f/m\) \cite{Newton1687}, the acceleration of the electrons
is large and the acceleration of the atomic nuclei is small; the
difference is a factor of more than 1000. Consequently, the electrons
are moving and responding to forces very quickly, and the nuclei are
not, then we fix the nucleus, \(\mathbf{R}_{I}\) becomes a constant,
thus the kinetic term for nucleus becomes zero. And the potential energy
for the repulsion between nucleus becomes a constant.
\begin{align}
\hat H_{\mathrm{el}} =
-\sum_{i=1}^{N}\frac{1}{2}\nabla_i^{2}
-\sum_{i=1}^{N}\sum_{I=1}^{M}\frac{Z_I}{|\mathbf r_i-\mathbf R_I|} \notag\\
+\sum_{1\le i<j\le N}\frac{1}{|\mathbf r_i-\mathbf r_j|}
+ \sum_{I<J}\frac{Z_I Z_J}{|\mathbf R_I-\mathbf R_J|}
\end{align}


This is the form that we are going to work with; a second useful
approach to the problem is use an \textbf{Ansatz}, which is a guess
solution guided by intuition, this normally depend on certain number of
parameters, then the problem becomes on optimize this \textbf{Ansatz}.

\subsubsection{Rayleigh Quotient}
We need a way to measure how well our ansatz \(\psi_{\theta}\) is doing, if our ansatz is "bad" then don't reflect the truly form of the system, most deep learning approaches use data sets to train their ansatz (model initialized on randoms parameters) in this case we don't need any external but just physical principles. Lets first introduce the \textbf{Rayleigh quotient}. If
\(A\) is an operator and \(x\) is a state, the number:
\begin{equation}
R_{A}(x)=\frac{ \langle x |A   |x\rangle}{\bra{x}x\rangle }
  \label{eq:eso}
\end{equation}
is the \textbf{expectation value} of that operator in that state. The
important for us is that if \(\psi\) is a wave function and \(\hat{H}\)
the \textbf{Hamiltonian}, then the Rayleigh quotient:
\begin{equation}
R_{\hat{H}}(\psi)=\frac{\braket{ \psi | \hat{H}| \psi}}{\braket{ \psi | \psi } }
\label{eq:}
\end{equation}

is the average (expected) energy of the system when it is in the state \(\psi\) \cite{Ritz1909Variational}.

\subsubsection{Variational Principle}

The variational principle for electronic systems states that the expectation value
for the binding energy obtained using an approximate wave function and
the exact Hamiltonian operator will be higher than or equal to the true
energy for the system \cite{GoldsteinCM}. This idea is really powerful. When implemented it
permits us to find the best approximate wavefunction from a given
wavefunction that contains one or more adjustable parameters, called a
trial wavefunction \cite{foulkes2001quantum} . A mathematical statement of the variational
principle is.

\begin{equation}
R_{\hat{H}}(\psi_{\text{ansatz}})\geq R_{\hat{H}}(\psi_{\text{true}})
\end{equation}

The true ground-state wave function \(\psi_{\text{true}}\) is the one
that minimizes the rayleigh quotient.

\begin{equation}
\psi_{0}=\underset{\psi}{\text{argmin}}( R_{\hat{H}}(\psi))
\end{equation}


So if we minimize the rayleigh quotient of our ansatz we are going to
be more near of the true wave function.


\subsubsection{Variational Monte Carlo}

To the process that we are going to use for optimize our ansatz is called Variational Monte Carlo (VMC)\cite{McMillan1965GroundStateHe4,bajdich2006pfaffian}. Now we can see to the rayleigh
quotient as a loss function \(\mathcal{L}\) with the form of.

\begin{equation}
  \mathcal{L}(\Psi_{\theta})=\frac{\bra{\Psi_{\theta}} \hat{H}\ket{\Psi_{\theta}} }{\braket{ \Psi_{\theta} | \Psi _{\theta}} }=\frac{\int d\mathbf{r}\Psi ^{*}(\mathbf{r})\hat{H}\Psi(\mathbf{r})}{\int d\mathbf{r}\Psi ^{*}(\mathbf{r})\Psi(\mathbf{r})}
\end{equation}

Evaluate that integral is hard, another smart approach is the follow,
define a probability distribution \(p_{\theta}\) with the follow form:
\begin{equation}
p_{\theta}(x)=\frac{\lvert \Psi_{\theta} (x)\rvert ^{2}}{\int dx'\Psi^{2}_{\theta}(x')}
\label{eq:prop}
\end{equation}

Realize that for compute \(p_{\theta}(x)\) for a specific \(x\) is
complicated due the integral that appears, this is going to be important
later. Defining the local energy \(E_{L}\) with:

\begin{equation}
E_{L}(x)=\Psi ^{-1}_{\theta}(x)\hat{H}\Psi_{\theta}(x)
\end{equation}

Then the loss becomes:
\begin{equation}
\mathcal{L}(\Psi_{\theta})=\int \frac{ \hat{H}\Psi_{\theta}(x)}{\Psi_{\theta}(x)}p_{\theta}(x)dx
\end{equation}

Which is the expected value of the local energy:

\begin{equation}
\mathcal{L}(\Psi_{\theta})=\mathbb{E}_{x\sim p_{\theta}}[E_{L}(x)]
\end{equation}

To optimize our wave function we need to compute the expectation and obtain its derivative for back propagation. We are going to use the Monte Carlo estimator for it. \cite{MetropolisUlam1949}:
\begin{equation} \mathcal{L}_{\theta}=\mathbb{E}_{x\sim p_{\theta}}[E_{L}(x)]\approx \frac{1}{M}\sum_{i=1}^{M} E_{L}(\mathbf{R}_{k})
\end{equation}
Whit \(\mathbf{R}_{k}\) are samples from the \(p_{\theta}\) probability distribution. This is \[
\mathbf{R}_{1},\dots,\mathbf{R}_{M}\sim p_{\theta}(\mathbf{R})
\]
We obtain \(E_{L}(R_k)\) using:
\begin{equation}
E_{L}(\mathbf{R}_{k})=\frac{\hat{H}\psi(\mathbf{R}_{k})}{\psi(\mathbf{R}_{k})}=-\frac{1}{2}\frac{\nabla^{2}\psi(\mathbf{R_{k}})}{\psi(\mathbf{R}_{k})}+V(\mathbf{R}_{k})
\end{equation}
Calculus tell us that for a any derivable function \(f\).
\begin{equation}
  \frac{\nabla^{2}f}{f}=[\nabla^{2}\log f+(\nabla f)^{2}]
\end{equation}
In practice is more numerically stable work using that form, thus:
\begin{align}
&E_{L}(\mathbf{R}_{k})= \notag\\& -\frac{1}{2}\sum_{i=1}^{N} \sum_{j=1}^{3} \left[ \frac{\partial ^{2} \log \lvert \Psi(x) \rvert }{\partial r_{ij}^{2}}+\left( \frac{\partial \log \lvert \Psi(x) \rvert }{\partial r_{ij}} \right)^{2} \right]+V(\mathbf{R_{k}})
\end{align}
The gradient of the energy respect to the parameters by a
parameterized wave functions is:
\begin{equation}
\nabla _{\theta}\mathcal{L}=2\mathbb{E}_{x\sim \Psi^{2}}[(E_{L}(x)-\mathbb{E}_{x'\sim\Psi^{2}}[E_{L}(x')])\nabla \log \lvert \Psi(x) \rvert ]
\label{eq:loss}
\end{equation}
\subsubsection{Metropolis Hastings Algorithm}
To obtain samples from the probability distribution \(p_{\theta}\) we are going to use the Metropolis Hasting algorithm (MH) \cite{Metropolis1953Equation} which is a Markov Chain Monte Carlo (MCMC) method used to obtain a sequence of random samples from a probability distribution. The
reason to use this method over another well knows methods (e.g.~example)
is that MH don't suffer of the \textit{Curse of Dimensionality} \cite{donohocurse} this is, the computationally cost don't explode while increasing the dimension of the problem, and since we are going to be working on high dimensions is good option use this method. The algorithm works like follow:

\begin{enumerate}
\item
  Take a initial configuration \(\mathbf{X}_{0}\in E\) arbitrary.
\item
  Propose \(\mathbf{X}'=\mathbf{X}_{0}+\eta\) ,where
  \(\eta \sim q(\eta)\), \(q\) is a probability density on \(E\) called
  \textbf{proposal kernel}. In our case we are going to sample from symmetric gaussian.
\item
  Compute the quantity:
\begin{equation*}
  A(\mathbf{X_{0}}, \mathbf{X}')=\text{min}\left( 1,\frac{\rho(\mathbf{X}')}{\rho(\mathbf{X}_{0})} \frac{q(\mathbf{X}'-\mathbf{X}_{0})}{q(\mathbf{X}_{0}-\mathbf{X}')}\right)
\end{equation*}

Where \(\rho\) is the target distribution (the one we want sample). In
  the case where \(q\), the proposal kernel is symmetric, this simplifies to:

\begin{equation}
  A(\mathbf{X}_{0},\mathbf{X}')=\text{min}\left( 1,\frac{\rho(\mathbf{X})}{\rho(\mathbf{X}_{0})} \right)
\end{equation}

Note that in our case \(\rho\) is equal to \(p_{\theta}\), we said that compute the integral factor is a challenge, but in this case it doesn't matter because:
\begin{equation}
\frac{p_{\theta}(\mathbf{X}')}{p_{\theta}(\mathbf{X}_{0})}=\frac{\lvert \psi_{\theta}(\mathbf{X}') \rvert ^{2}/\int \lvert \psi_{\theta} \rvert ^{2}dx}{\lvert \psi_{\theta}(\mathbf{X}_{0}) \rvert ^{2}/\int \lvert \psi_{\theta} \rvert ^{2}dx}=\frac{\lvert \psi_{\theta}(\mathbf{X'}) \rvert ^{2}}{\lvert \psi_{\theta}(\mathbf{X}_{0}) \rvert ^{2}}
\end{equation}

\item
  Generate a uniform number \(U\in[0,1]\)
\item
  If: \(U<A(\mathbf{X}_{0}\to \mathbf{X'}_{l})\) then
  \(\mathbf{X_{1}}=\mathbf{X}'\), otherwise try another \(\mathbf{X}'\).
\item
  Repeat until obtain \(N_{eq}\) accepted samples, for a large $N_{\text{eq}}$ the changes between samples stabilizes
 (we reach a stationary distribution), this phase is called \textbf{burn in}.
\item
  From \(\mathbf{X}_{N_{\text{eq}}}\) generate another \(M\) samples until obtain
  the sample \(\mathbf{X}_{N_{\text{eq}}+M+1}\). In each sample generates \(E_{L}(\mathbf{R}_{k})\) then average to obtain \(\mathbb{E}(E_{L})\).
\end{enumerate}

Once that you obtain $\mathbb{E}(E_L)$ and using equation \ref{eq:loss} we can optimize our net using backpropagation \cite{RumelhartHintonWilliams1986}.

\subsection{Deep Learning Fundamentals}

This subsection introduces the core concepts of Deep Learning that are going to be applied in this work.

\subsubsection{Multi Layer Perceptron}
A multi layer perceptron (MLP) is a nonlinear mapping \(\mathcal{F}:\mathbb{R}^{\text{in}}\to \mathbb{R}^{\text{out}}\) from a input pattern $\mathbf{x}$ to an output vector $\mathbf{y}$ \cite{RumelhartHintonWilliams1986}
,is the composition of
  \(L\) layers, the first layer is called the input layer, the last,
  output layer, and the intermediates, hidden layers. In each layer we
  find a arbitrary number of neurons and an affine map \(\mathbf{z}^{(l)},l\in \{ L,L-1,\dots,2 \}\) (\(l=1\) is the input
  layer) of the follow form.
\begin{equation}
\mathbf{z}^{(l)}=\mathbf{W}^{(l)}\mathbf{a}^{(l-1)}+\mathbf{b}^{(l)}
\end{equation}
Where \(\mathbf{W}^{(l)}\) called weight matrix and \(\mathbf{b}^{(l)}\) the bias vector of the \(l\) layer. We use a non-linear function \(\sigma ^{(l)}\) in the \(l\) layer (typically Softmax, ReLu, Tanh), thus the output of each layer is:
\begin{equation}
f^{(l)}=\sigma ^{(l)}\circ \mathbf{z}^{(l)}
\end{equation}
Where \(\circ\) means function composition. A MLP is the composition of all the layers.
\begin{equation}
  \mathcal{F}=f^{(L)}\circ f^{(L-1)}\circ\dots \circ f^{(1)}
\end{equation}
We call parameters to the set of all the weights and bias of each layer, it's represented it with the symbol \(\theta\).
  \[\{ \mathbf{W}^{(l)},\mathbf{b}^{(l)}\}_{l=2}^{L}=\theta\] You
  typically train a MLP, using a training data set, a loss function (e.g
  Mean Square Error, Mean Absolute Error, Cross entropy) and an optimizer (e.g GD, SGD, ADAM). Additionally you can use regularization techniques such as dropout to improve the generalization of the Net. \cite{kingma2017adammethodstochasticoptimization, goodfellowDeepLearning2016, nielsenNeuralNetworksDeep2015, bishop}
\subsubsection{Natural gradient Descent}\label{natural-gradient-descent}

As mentioned above, there are many ways to update the parameters. All of them
implicitly assume that the parameter space
\(\Theta \subset \mathbb{R}^d\) is equipped with the standard Euclidean
metric, so that ``length'' and ``steepest descent'' are measured with
respect to \(\|\Delta\theta\|_2\).

In our case the loss \(\mathcal{L}(\theta)\) depends on a probability distribution \(p_\theta\), not just on \(\theta\) directly. For example, in variational Monte Carlo we work with equation \cref{eq:prop} where \(\theta\) parametrizes an entire family of probability densities
over configurations \(x\). It is therefore more natural to measure
distances between \emph{distributions} \(p_\theta\) and
\(p_{\theta+\Delta\theta}\), rather than between the parameter vectors
themselves.

A canonical way to measure the distance between nearby probability
distributions is the Kullback--Leibler (KL) divergence \cite{KullbackLeibler1951}.
\begin{equation}
\mathrm{KL}\big(p_\theta \,\|\, p_{\theta+\Delta\theta}\big) = \mathbb{E}_{x\sim p_\theta}\!\left[\log\frac{p_\theta(x)}{p_{\theta+\Delta\theta}(x)}\right]
\end{equation}
For small steps \(\Delta\theta\) one can show that a second--order
Taylor expansion of the KL gives \[
\mathrm{KL}\big(p_\theta \,\|\, p_{\theta+\Delta\theta}\big)
= \tfrac12\,\Delta\theta^\top \mathcal{F}(\theta)\,\Delta\theta + \mathcal{O}(\|\Delta\theta\|^3),
\] where \(\mathcal{F}(\theta)\) is the Fisher Information Matrix (FIM) \cite{Fisher1922Foundations}.
To define it, introduce the \textbf{score function}
_\theta(x) = \nabla_\theta \log p(x\mid \theta) \in \mathbb{R}^d
\]
then the FIM is:
\begin{equation}
\mathcal{F}(\theta) = \mathbb{E}_{x\sim p(\cdot\mid\theta)}\!\big[\,s_\theta(x)\,s_\theta(x)^{\mathsf T}\big].
\end{equation}
The set of distributions:
\begin{equation}
\mathcal{M} = \{\, p_\theta(z)\;|\; \theta \in \Theta \subset \mathbb{R}^d \,\}
\end{equation}
can be viewed as a differentiable manifold, and
\(\mathcal{F}(\theta)\) defines a Riemannian metric on its tangent
space. Concretely, for tangent vectors \(u,v \in \mathbb{R}^d\) at
\(\theta\) we define the inner product:
\begin{equation}
\langle u,v \rangle_\theta = u^{\mathsf T}\,\mathcal{F}(\theta)\,v.
\end{equation}
This metric says: two parameter directions are ``close'' if they induce similar infinitesimal changes in the \emph{distribution} \(p_\theta\).
To obtain the steepest descent direction with this non-Euclidean metric where a variation \(\Delta\theta\) that decreases \(\mathcal{L}(\theta)\) the fastest, among all directions with fixed ``length'' \(\|\Delta\theta\|_\theta^2 = \Delta\theta^\top \mathcal{F}(\theta)\,\Delta\theta\) is necessary resolve a constrained optimization problem. That direction is called \textbf{natural gradient} direction and it takes the form of \cite{Amari1998NaturalGW}:

\begin{equation}
\Delta\theta_{\text{nat}} \;\propto\; -\,\mathcal{F}(\theta)^{-1}\,\nabla_\theta \mathcal{L}(\theta).
\end{equation}
Thus the natural gradient descent update is:
\begin{equation}
\Delta\theta_{\text{nat}} = -\,\eta\,\mathcal{F}(\theta)^{-1}\,\nabla_\theta \mathcal{L}(\theta)
\end{equation}
where \(\eta>0\) is a step size. Compared with the usual gradient
\(\nabla_\theta \mathcal{L}\), the factor \(\mathcal{F}^{-1}\)
``preconditions'' the gradient by the local geometry of the model's
probability distribution: directions that barely change \(p_\theta\) are
amplified, directions that change it a lot are damped.
Natural gradient descent is therefore meaningful exactly in the
situation we care about: when the loss depends on the parameters
\emph{through} a probability model \(p_\theta\) (e.g.~likelihood,
cross-entropy, KL, variational objectives, variational Monte Carlo
energy, etc.) \cite{Amari1998NaturalGW}.
\subsubsection{Kronecker Factored Approximate Curvature}\label{kronecker-factored-approximate-curvature}

Directly computing and inverting the full Fisher matrix
\(\mathcal{F}(\theta)\) is infeasible for modern neural networks, since
\(\theta\) can have millions of components. Kronecker Factored
Approximate Curvature (KFAC) \cite{MartensGrosse2015KFAC} is an efficient approximation that makes
natural gradient updates practical for layered networks.
We sketch the construction for a fully connected layer \(\ell\) with
weight matrix \(W_\ell\) and (for simplicity) no bias. Bias terms can be
included by augmenting the activations with a constant \(1\); we comment on this below.

We begin with the forward definitions. Let \(\mathbf{a}_\ell\) be the \textbf{input (activation) to layer \(\ell\)}. This is the column vector of activations coming into layer \(\ell\). For the first hidden layer, \(\mathbf{a}_1\) is just the (possibly preprocessed) input. For deeper layers it is the nonlinearity output from the previous layer.

The \textbf{pre-activation at layer \(\ell\)} is simply the quantity:
\begin{equation}
\mathbf{h}_\ell = W_\ell \,\mathbf{a}_\ell
\end{equation}

And the \textbf{output activation of layer \(\ell\)}:

\begin{equation}
\tilde{\mathbf{a}}_\ell = \phi(\mathbf{h}_\ell)
\end{equation}

where \(\phi\) is applied element-wise. In many notations
  \(\tilde{\mathbf{a}}_\ell\) would become the input to the next layer, but to keep notation consistent with the Fisher block for \(W_\ell\).

Now with the backward definitions.Let the loss for a single sample be \(\mathcal{L}(\theta)\) (for example,
negative log-likelihood or negative log of the wave-function
probability). Define the \textbf{backward sensitivity} (or error signal)
at layer \(\ell\) as

\begin{equation}
\mathbf{e}_\ell = \frac{\partial \mathcal{L}}{\partial \mathbf{h}_\ell} \in \mathbb{R}^{m_\ell}
\end{equation}

This is computed via backpropagation. At the output layer \(L\):

\begin{equation}
\mathbf{e}_L = \frac{\partial \mathcal{L}}{\partial \mathbf{h}_L} = \left(\frac{\partial \mathcal{L}}{\partial \tilde{\mathbf{a}}_L}\right) \odot \phi'(\mathbf{h}_L)
\end{equation}
where \(\odot\) is the element-wise product or also Hadamard
product. For hidden layers \(\ell < L\):
\begin{equation}
\mathbf{e}_\ell = \frac{\partial \mathcal{L}}{\partial \mathbf{h}_\ell} = \left(W_{\ell+1}^{\mathsf T} \mathbf{e}_{\ell+1}\right) \odot \phi'(\mathbf{h}_\ell)
\end{equation}

  In the context of natural gradient for probabilistic models,
\(\mathcal{L}\) is often chosen as \(-\log p(X\mid\theta)\), so up to a
sign we can also think of \(\mathbf{e}_\ell\) as \[
\mathbf{e}_\ell = \frac{\partial \log p(X\mid\theta)}{\partial \mathbf{h}_\ell}.
\]
For a single sample, using the chain rule,
\begin{equation}
\frac{\partial \mathcal{L}}{\partial W_\ell} = \frac{\partial \mathcal{L}}{\partial \mathbf{h}_\ell} \frac{\partial \mathbf{h}_\ell}{\partial W_\ell} = \mathbf{e}_\ell\, \mathbf{a}_\ell^{\mathsf T}
\end{equation}
If instead of \(\mathcal{L}\) we use \(\log p(X\mid\theta)\) (as in the
Fisher definition), we get:
\begin{equation*}
\frac{\partial \log p(X\mid\theta)}{\partial W_\ell} = \mathbf{e}_\ell\, \mathbf{a}_\ell^{\mathsf T},
\end{equation*}
with \(\mathbf{e}_\ell = \partial \log p / \partial \mathbf{h}_\ell\). Now vectorize the gradient. Using the standard identity:
\begin{equation*}
\mathrm{vec}(uv^{\mathsf T}) = v \otimes u,
\end{equation*}
with \(u = \mathbf{e}_\ell\) and \(v = \mathbf{a}_\ell\), we obtain \[
\frac{\partial \log p(X\mid\theta)}{\partial \mathrm{vec}(W_\ell)}
= \mathrm{vec}\!\left(\frac{\partial \log p}{\partial W_\ell}\right)
= \mathrm{vec}(\mathbf{e}_\ell\,\mathbf{a}_\ell^{\mathsf T})
= \mathbf{a}_\ell \otimes \mathbf{e}_\ell.
\]
This gives the key structural form used by KFAC.
The Fisher block associated with the parameters \(W_\ell\) is \[
\mathcal{F}_\ell
= \mathbb{E}_{p(\mathbf{X})}\!\left[
\frac{\partial \log p(X\mid\theta)}{\partial \mathrm{vec}(W_\ell)}
\frac{\partial \log p(X\mid\theta)}{\partial \mathrm{vec}(W_\ell)}^{\mathsf T}
\right].
\]
Plugging in the expression above,
\begin{equation}
\mathcal{F}_\ell = \mathbb{E}_{p(\mathbf{X})}\!\big[ (\mathbf{a}_\ell \otimes \mathbf{e}_\ell) (\mathbf{a}_\ell \otimes \mathbf{e}_\ell)^{\mathsf T} \big].
\end{equation}

Here \(p(\mathbf{X})\) denotes the distribution over inputs and labels
(or configurations, in the VMC case). In practice this expectation is
approximated by averaging over a mini-batch of samples \(X\) and the
corresponding forward/backward passes that produce \(\mathbf{a}_\ell\)
and \(\mathbf{e}_\ell\).
Computing and inverting \(\mathcal{F}_\ell\) directly is still
expensive, because its dimension is \[
(\text{dim}(\mathbf{a}_\ell)\,\text{dim}(\mathbf{e}_\ell))
\times
(\text{dim}(\mathbf{a}_\ell)\,\text{dim}(\mathbf{e}_\ell)).
\] KFAC makes two key approximations to make this tractable.
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Block--diagonal across layers.}\\
  Off--diagonal blocks \(\mathcal{F}_{ij}\) are assumed negligible when
  \(\theta_i\) and \(\theta_j\) belong to different layers. This makes
  the Fisher approximately block--diagonal, with one block per layer.
\item
  \textbf{Kronecker factorization within each layer.}\\
  Inside a layer, KFAC assumes that the correlation between activations
  and errors factorizes:
  \begin{align}
  \mathcal{F}_\ell
  =& \mathbb{E}_{p(\mathbf{X})}\!\big[
  (\mathbf{a}_\ell \otimes \mathbf{e}_\ell)
  (\mathbf{a}_\ell \otimes \mathbf{e}_\ell)^{\mathsf T}
  \big]
 \notag \\=& \mathbb{E}_{p(\mathbf{X})}\!\big[
  (\mathbf{a}_\ell\mathbf{a}_\ell^{\mathsf T}) \otimes
  (\mathbf{e}_\ell\mathbf{e}_\ell^{\mathsf T})
  \big]
  \notag \\\approx &
  \mathbb{E}_{p(\mathbf{X})}[\mathbf{a}_\ell\mathbf{a}_\ell^{\mathsf T}]
  \;\otimes\;
  \mathbb{E}_{p(\mathbf{X})}[\mathbf{e}_\ell\mathbf{e}_\ell^{\mathsf T}]
  \end{align}
\end{enumerate}
Define the \emph{activation covariance} and \emph{error covariance}: \[
A_\ell = \mathbb{E}_{p(\mathbf{X})}[\mathbf{a}_\ell\mathbf{a}_\ell^{\mathsf T}],
\qquad
S_\ell = \mathbb{E}_{p(\mathbf{X})}[\mathbf{e}_\ell\mathbf{e}_\ell^{\mathsf T}].
\] In practice these expectations are updated as running averages over
mini-batches: \[
A_\ell \approx \frac{1}{B}\sum_{b=1}^B \mathbf{a}_\ell^{(b)} \mathbf{a}_\ell^{(b)\mathsf T},
\qquad
S_\ell \approx \frac{1}{B}\sum_{b=1}^B \mathbf{e}_\ell^{(b)} \mathbf{e}_\ell^{(b)\mathsf T},
\] where \(b\) indexes samples in the batch and
\(\mathbf{a}_\ell^{(b)}, \mathbf{e}_\ell^{(b)}\) are obtained by a
standard forward and backward pass for that sample. With this
approximation we have \[
\mathcal{F}_\ell \approx A_\ell \otimes S_\ell.
\]

The crucial property of the Kronecker product is that \[
(A_\ell \otimes S_\ell)^{-1}
= A_\ell^{-1} \otimes S_\ell^{-1},
\] so the inverse of the (huge) layer--Fisher block can be obtained by
inverting the much smaller matrices \(A_\ell\) and \(S_\ell\). Thus the
natural gradient update for the weights of layer \(\ell\) becomes
\begin{equation}
\Delta\theta_{\text{nat},\ell} \approx -\,\eta\,\big(A_\ell^{-1} \otimes S_\ell^{-1}\big)\, \nabla_{\mathrm{vec}(W_\ell)} \mathcal{L}.
\end{equation}
In summary, KFAC replaces the intractable inverse \[
\mathbb{E}_{p(\mathbf{X})}\big[ (\mathbf{a}_\ell\otimes \mathbf{e}_\ell)
(\mathbf{a}_\ell\otimes \mathbf{e}_\ell)^{\mathsf T} \big]^{-1}
\] by the efficiently computable:
\begin{align}
\mathcal{F}_{\ell}^{-1} = & \; \mathbb{E}_{p(\mathbf{X})}\big[(\mathbf{a}_\ell\otimes \mathbf{e}_\ell)
(\mathbf{a}_\ell\otimes \mathbf{e}_\ell)^{\mathsf T}\big]^{-1}
\notag \\ \approx & \;
\mathbb{E}_{p(\mathbf{X})}[\mathbf{a}_\ell\mathbf{a}_\ell^{\mathsf T}]^{-1}
\otimes
\mathbb{E}_{p(\mathbf{X})}[\mathbf{e}_\ell\mathbf{e}_\ell^{\mathsf T}]^{-1}
\end{align}

which captures the dominant curvature structure while keeping the
cost of natural gradient descent comparable to standard first--order
methods. We have ignored biases above for clarity. In practice one can
either (i) augment \(\mathbf{a}_\ell\) with a constant \(1\) to absorb
biases into \(W_\ell\), or (ii) maintain separate smaller KFAC factors
for biases; both approaches preserve the same Kronecker structure.

\subsubsection{Self-Attention and Multi-Head Self-Attention}\label{self-attention-and-multi-head-self-attention}
The idea of an \emph{attention mechanism} was introduced in neural
machine translation by Bahdanau et al. @bahdanau2014neural Instead of
compressing an entire input sequence into a single fixed-size vector,
the model learns to \textbf{focus} on different parts of the input when
generating each output token.

Given a query vector \(\mathbf{q} \in \mathbb{R}^{d_h}\) and a set of
key--value pairs \(\{(\mathbf{k}_j, \mathbf{v}_j)\}_{j=1}^T\) with
\(\mathbf{k}_j, \mathbf{v}_j \in \mathbb{R}^{d_h}\), the (scaled
dot--product) attention mechanism computes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Compatibility scores} \[
  e_j \;=\; \frac{\mathbf{q}^\top \mathbf{k}_j}{\sqrt{d_h}}, \qquad j = 1,\dots,T,
  \]
\item
  \textbf{Normalized attention weights} \[
  \alpha_j \;=\; \frac{\exp(e_j)}{\sum_{m=1}^{T} \exp(e_m)}
  \;=\; \text{Softmax}_j\!\left( \frac{\mathbf{q}^\top \mathbf{k}_j}{\sqrt{d_h}} \right),
  \]
\item
  \textbf{Weighted sum of values} \[
  \mathbf{o} \;=\; \sum_{j=1}^{T} \alpha_j \mathbf{v}_j.
  \]
\end{enumerate}

Intuitively, the query \(\mathbf{q}\) asks: \emph{``which elements
  of the set are relevant to me now?''} The keys \(\mathbf{k}_j\) encode \emph{what each element offers}, and the values \(\mathbf{v}_j\) encode \emph{what we take from each
  element once we decide to pay attention to it}.

In \textbf{self-attention}, the queries, keys, and values are all
obtained from the \textbf{same} set of input vectors.\\
Consider a sequence of input embeddings \[
\mathbf{x}_1, \dots, \mathbf{x}_T \in \mathbb{R}^{d},
\] and stack them into a matrix \[
\mathbf{X} \in \mathbb{R}^{T \times d}, \quad
\mathbf{X} =
\begin{bmatrix}
\mathbf{x}_1^\top \\
\vdots \\
\mathbf{x}_T^\top
\end{bmatrix}.
\] To build one attention \textbf{head} of dimension \(d_h\), we
introduce three learnable matrices: \[
\mathbf{W}^Q \in \mathbb{R}^{d \times d_h}, \quad
\mathbf{W}^K \in \mathbb{R}^{d \times d_h}, \quad
\mathbf{W}^V \in \mathbb{R}^{d \times d_h}.
\]
We then compute queries, keys, and values:
\begin{align}
\mathbf{Q} = \mathbf{X} \mathbf{W}^Q \in \mathbb{R}^{T \times d_h} \notag \\
    \mathbf{K} = \mathbf{X} \mathbf{W}^K \in \mathbb{R}^{T \times d_h} \notag \\
    \mathbf{V} = \mathbf{X} \mathbf{W}^V \in \mathbb{R}^{T \times d_h} \notag
\end{align}
The \textbf{scaled dot-product self-attention} for this head is:
\begin{equation}
\text{Attention}(\mathbf{Q}, \mathbf{K}, \mathbf{V}) = \text{Softmax}\!\left( \frac{\mathbf{Q}\mathbf{K}^\top}{\sqrt{d_h}} \right) \mathbf{V}
\end{equation}
where the softmax is applied row-wise. Element-wise, the output at
position \(t\) is \[
\mathbf{o}_t = \sum_{j=1}^{T} \alpha_{tj} \mathbf{v}_j \; \text{with} \
\alpha_{tj} = \frac{\exp\!\left( \mathbf{q}_t^\top \mathbf{k}_j / \sqrt{d_h} \right)}{\sum_{m=1}^{T} \exp\!\left( \mathbf{q}_t^\top \mathbf{k}_m / \sqrt{d_h} \right)}.
\] You can think of this as: \emph{each position \(t\) in the sequence
``looks at'' every other position \(j\) and decides how much to care
about it}. \

A single head can only look at interactions in one ``representation
subspace'' of dimension \(d_h\).
\textbf{Multi-head attention} uses several heads in parallel, each with its own projection matrices, so that different types of relationships can be captured simultaneously. Let \(n_h\) be the number of heads. For
head \(i = 1, \dots, n_h\) we have \[
\mathbf{W}_i^Q,\, \mathbf{W}_i^K,\, \mathbf{W}_i^V \in \mathbb{R}^{d \times d_h}.
\]
Head \(i\) computes: \[
\text{head}_i(\mathbf{X})
= \text{Attention}(\mathbf{X}\mathbf{W}_i^Q,\, \mathbf{X}\mathbf{W}_i^K,\, \mathbf{X}\mathbf{W}_i^V)
\in \mathbb{R}^{T \times d_h}.
\] The outputs of all heads are concatenated along the feature dimension
and then linearly mixed: \[
\mathbf{U}
= \left[ \text{head}_1(\mathbf{X}) \,;\, \dots \,;\, \text{head}_{n_h}(\mathbf{X}) \right]
\in \mathbb{R}^{T \times (n_h d_h)},
\] \[
\mathbf{O} = \mathbf{U} \mathbf{W}^O, \qquad
\mathbf{W}^O \in \mathbb{R}^{(n_h d_h) \times d}.
\] If we focus on one time step \(t\) and head \(i\), we can write the
per-head output as \[
\mathbf{o}_{t,i} = \sum_{j=1}^{T}
\text{Softmax}_j\!\left( \frac{\mathbf{q}_{t,i}^\top \mathbf{k}_{j,i}}{\sqrt{d_h}} \right)\mathbf{v}_{j,i},
\] and the final vector at time \(t\) after concatenation and output
projection as \[
\mathbf{u}_t =
\mathbf{W}^{O}
\begin{bmatrix}
\mathbf{o}_{t,1} \\
\vdots \\
\mathbf{o}_{t,n_h}
\end{bmatrix}.
\] From a physics point of view, you can read multi-head attention as
\textbf{several different ``channels'' of interaction}: one head might
focus on short-range relations, another on long-range ones, another on
some specific pattern (e.g.~symmetry, local structure), and so on.
\subsubsection{Transformer Architecture}\label{transformer-architecture}
The \textbf{Transformer} was introduced
with the slogan \emph{``Attention Is All You Need.''} \cite{Vaswani2017}.
Its core building block is a \textbf{layer} that combines {multi-head self-attention} and {position-wise feed-forward network (FFN)} (Both sublayers use \textbf{residual connections} and \textbf{layer normalization}).

For an input sequence \(\mathbf{X} \in \mathbb{R}^{T \times d}\) (already
including positional information), one Transformer layer performs:
 \[
   \mathbf{H} = \text{MHA}(\mathbf{X}), \qquad
   \mathbf{X}^{(1)} = \text{LayerNorm}\!\left( \mathbf{X} + \mathbf{H} \right).
\]
The {feed-forward sublayer} makes: (applied independently at each position)
\[
   \text{FFN}(\mathbf{x}) = \sigma\!\left( \mathbf{x}\mathbf{W}_1 + \mathbf{b}_1 \right)\mathbf{W}_2 + \mathbf{b}_2,
\] typically with \(\sigma\) a nonlinearity such as ReLU or GELU and an
intermediate width \(d_{\text{ff}} > d\). At the sequence level:\\
\[
   \mathbf{Z} = \text{FFN}(\mathbf{X}^{(1)}), \qquad
   \mathbf{X}^{\text{out}} = \text{LayerNorm}\!\left( \mathbf{X}^{(1)} + \mathbf{Z} \right).
\] Stacking several such layers yields a deep architecture where, at
each layer, every position can interact with every other position
through self-attention.

In the original formulation \cite{Vaswani2017}, \textbf{positional encodings} (sinusoidal
or learned) are added to the embeddings so that the model can
distinguish different positions in the sequence: \[
\mathbf{X}_0 = \mathbf{E} + \mathbf{P},
\] where \(\mathbf{E}\) are token embeddings and \(\mathbf{P}\) are
positional encodings.

\subsubsection{Why Transformers Instead of RNNs or
LSTMs?}\label{why-transformers-instead-of-rnns-or-lstms}

Recurrent Neural Networks (RNNs) \cite{elman1990finding} and Long Short-Term Memory (LSTM) \cite{hochreiter1997long} networks process the sequence \textbf{sequentially} this is each new state depends on the previous one. This has two important consequences:
1. Information must flow through many time steps, which can lead to vanishing or exploding gradients and makes it hard to model very
long-range interactions. 2. Poor parallelization because each step
depends on the previous one, you cannot compute all time steps in
parallel. Training and inference are inherently sequential. Transformers
address both issues: - Global interactions in one step, self-attention
allows every position to directly interact with every other position in
a \emph{single} layer, which is ideal when we care about
\emph{all-to-all} correlations \cite{Vaswani2017} (as in many-electron systems, where each
electron ``feels'' all the others). - Full parallelism over sequence
length. Given \(\mathbf{X}\), the matrices \(\mathbf{Q}\),
\(\mathbf{K}\), \(\mathbf{V}\) and the attention outputs for all time
steps are computed via matrix multiplications. This is extremely
efficient on modern accelerators (GPUs/TPUs) \cite{kaplan2020scalinglawsneurallanguage}. For a many-electron
Schrödinger equation, the wave function depends on the joint
configuration of all particles. A Transformer-based ansatz naturally
provides a way for each electron's representation to \textbf{look at all
other electrons} and the nuclei, capturing complex correlation patterns
through attention, while remaining highly parallelizable.

\section{Psi Former Model}\label{psi-former-model}

\subsection{Fermi Net}\label{fermi-net}

A very important work for us is FermiNet \cite{Pfau_2020}. As shown at \cref{fig:fermi} it uses
deep neural networks to represent \textbf{orbitals} and then combines
them into a sum of Slater determinants. At the top level, the ansatz is
a linear combination of \(K\) determinant products
\begin{equation}
\psi(\mathbf{x}_1,\dots,\mathbf{x}_n) = \sum_{k=1}^K \omega_k \,\det[\Phi^{k}],
\end{equation}
where \(\omega_k\) are learnable coefficients and \(\Phi^k\) is a
matrix of single-particle orbitals. For a system without explicit spin
separation one can write \[
\det[\Phi^k] =
\begin{vmatrix}
\phi_{1}^{k}(\mathbf{x}_{1})  & \dots  &  \phi_{1}^{k}(\mathbf{x}_{n}) \\
\vdots   &  & \vdots  \\
\phi_{n}^{k}(\mathbf{x}_{1}) & \dots & \phi_{n}^{k}(\mathbf{x}_{n})
\end{vmatrix}
= \det[\phi_i^k(\mathbf{x}_j)].
\] Here \(\phi_i^k\) is the \(i\)-th orbital in determinant \(k\), and
we evaluate it on the coordinates of electron \(j\).

However, in FermiNet we are dealing with electrons with spin, so things
are slightly more structured, and the orbitals depend on \textbf{all}
electron coordinates, not only on the one being ``plugged in''. That is
why we write the orbitals as \[
\phi^{k\alpha}_i\big(\mathbf{r}^\alpha_j;\{\mathbf{r}^\alpha_{/j}\};\{\mathbf{r}^{\bar{\alpha}}\}\big),
\] where: - \(\alpha \in \{\uparrow,\downarrow\}\) is the spin sector, -
\(\mathbf{r}^\alpha_j\) is the position of electron \(j\) with spin
\(\alpha\), - \(\{\mathbf{r}^\alpha_{/j}\}\) denotes the positions of
all \textbf{other} electrons with spin \(\alpha\), -
\(\{\mathbf{r}^{\bar{\alpha}}\}\) denotes the positions of electrons
with the opposite spin.

So the orbital evaluated on electron \(j\) ``knows'' about all other
electrons. The index \(i\) correspond to orbital index (row of the determinant), \(j\) to electron index (column of the determinant), \(\alpha,\beta\) to spin labels (\(\uparrow\) or \(\downarrow\)) and \(k\) to determinant index in the sum.
\subsubsection{Input coordinates and
features}\label{input-coordinates-and-features-1}
We denote by \(\mathbf{r}^\uparrow_1,\dots,\mathbf{r}^\uparrow_{n^\uparrow}\) the
coordinates of spin-up electrons,
\(\mathbf{r}^\downarrow_1,\dots,\mathbf{r}^\downarrow_{n^\downarrow}\)
the coordinates of spin-down electrons, \(\mathbf{R}_I\) the positions
of nuclei, \(I=1,\dots,N_\text{nuc}\).
The network builds two types of features:
\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Electron--nucleus features} for each electron \(i\) with spin
  \(\alpha\): \[
  \mathbf{h}^{0,\alpha}_i
  = \text{concatenate}\Big(
      \mathbf{r}^\alpha_i - \mathbf{R}_I,\;
      \big|\mathbf{r}^\alpha_i - \mathbf{R}_I\big|
      \ \forall\, I
    \Big).
  \] This produces a feature vector that contains, for electron
  \((i,\alpha)\), all its relative position vectors to each nucleus,
  plus their distances.
\item
  \textbf{Electron--electron features} for each pair of electrons
  \((i,\alpha)\) and \((j,\beta)\): \[
  \mathbf{h}^{0,\alpha\beta}_{ij}
  = \text{concatenate}\Big(
      \mathbf{r}^\alpha_i - \mathbf{r}^\beta_j,\;
      \big|\mathbf{r}^\alpha_i - \mathbf{r}^\beta_j\big|
      \ \forall\, j,\beta
    \Big).
  \] For fixed \((i,\alpha)\), we build such features for all other
  electrons \((j,\beta)\), capturing their relative positions and
  distances.
\end{enumerate}

The superscript \(0\) indicates that these are the features at layer
\(\ell=0\) (input to the deep network). At deeper layers we will keep
updating  \(\mathbf{h}^{\ell\alpha}_i\) (single-electron features),
\(\mathbf{h}^{\ell\alpha\beta}_{ij}\) (pairwise features), for
\(\ell = 0,1,\dots,L-1\).

\begin{figure*}[htbp]
    \centering
    \includegraphics[width=0.5\textwidth]{img/psiformer.png}
    \caption{Psiformer uses a single stream of self attention layers, acting on nuclear-electron features only. Electron-electron features appear only via the Jastrow factor. Image source from \cite{vonglehn2023selfattentionansatzabinitioquantum}}
    \label{fig:psif}
\end{figure*}
\subsubsection{Mixing and updating features across
layers}\label{mixing-and-updating-features-across-layers-1}

At each hidden layer \(\ell\), we want each electron's features to
depend on \emph{all} other electrons, in a permutation-symmetric way. To
do this, we form \textbf{averages} over electrons of the same or
opposite spin.

First, define global spin-averaged single-electron features \[
\mathbf{g}^{\ell\uparrow} =
\frac{1}{n^\uparrow}\sum_{j=1}^{n^\uparrow}\mathbf{h}^{\ell\uparrow}_j,
\qquad
\mathbf{g}^{\ell\downarrow} =
\frac{1}{n^\downarrow}\sum_{j=1}^{n^\downarrow}\mathbf{h}^{\ell\downarrow}_j.
\]

Next, for each electron \((i,\alpha)\), define averaged pairwise
features: \[
\mathbf{g}^{\ell\alpha\uparrow}_i
= \frac{1}{n^\uparrow}\sum_{j=1}^{n^\uparrow}\mathbf{h}^{\ell\alpha\uparrow}_{ij},
\qquad
\mathbf{g}^{\ell\alpha\downarrow}_i
= \frac{1}{n^\downarrow}\sum_{j=1}^{n^\downarrow}\mathbf{h}^{\ell\alpha\downarrow}_{ij}.
\]

Now we \emph{concatenate} all this information into a single feature
vector for electron \((i,\alpha)\):
\begin{align}
&\big(
\mathbf{h}^{\ell\alpha}_i,
\frac{1}{n^\uparrow}\sum_{j=1}^{n^\uparrow}\mathbf{h}^{\ell\uparrow}_j,
\frac{1}{n^\downarrow}\sum_{j=1}^{n^\downarrow}\mathbf{h}^{\ell\downarrow}_j,
\frac{1}{n^\uparrow}\sum_{j=1}^{n^\uparrow}\mathbf{h}^{\ell\alpha\uparrow}_{ij},
\frac{1}{n^\downarrow}\sum_{j=1}^{n^\downarrow}\mathbf{h}^{\ell\alpha\downarrow}_{ij}
\big)
\notag\\=&
\big(\mathbf{h}^{\ell\alpha}_i, \mathbf{g}^{\ell\uparrow}, \mathbf{g}^{\ell\downarrow},
\mathbf{g}^{\ell\alpha\uparrow}_i, \mathbf{g}^{\ell\alpha\downarrow}_i \big)  = \mathbf{f}^{\ell\alpha}_i \notag
\end{align}


This \(\mathbf{f}^{\ell\alpha}_i\) is what enters the
\textbf{single-electron MLP} at layer \(\ell\). The update is \[
\mathbf{h}^{\ell+1,\alpha}_i
= \tanh\big(\mathbf{V}^\ell \mathbf{f}^{\ell\alpha}_i + \mathbf{b}^\ell\big) + \mathbf{h}^{\ell\alpha}_i
\] where \(\mathbf{V}^\ell\) and \(\mathbf{b}^\ell\) are learnable
weights and biases, shared between electrons (for the given spin
sector). The residual connection \(+\mathbf{h}^{\ell\alpha}_i\)
stabilizes training.

In parallel, the pairwise features are updated with a \textbf{pairwise
MLP}: \[
\mathbf{h}^{\ell+1,\alpha\beta}_{ij}
= \tanh\big(\mathbf{W}^\ell \mathbf{h}^{\ell\alpha\beta}_{ij} + \mathbf{c}^\ell\big)
+ \mathbf{h}^{\ell\alpha\beta}_{ij},
\] with weights \(\mathbf{W}^\ell\) and biases \(\mathbf{c}^\ell\),
again shared over all pairs \((i,j,\alpha,\beta)\).

By repeating these updates for \(\ell = 0,\dots,L-1\), we eventually
obtain \textbf{final single-electron features} \[
\mathbf{h}^{L\alpha}_j \quad \text{for each electron } j \text{ of spin } \alpha.
\] Notice how the indices work:  \(\ell\) runs over layers and
disappears at the end, \(i\) or \(j\) always refer to a specific
electron within a spin sector, \(\alpha,\beta\) tell you which spin
sector that electron belongs to.

\subsubsection{From final features to
orbitals}\label{from-final-features-to-orbitals-1}

The final orbitals are built as a function of the last-layer features
\(\mathbf{h}^{L\alpha}_j\), plus some additional ``envelope'' factors
that handle the long-range decay and cusp conditions. For each
determinant index \(k\), spin \(\alpha\), orbital index \(i\), and
electron \(j\) we define
\[
\begin{aligned}
\phi^{k\alpha}_i\big(\mathbf{r}^\alpha_j; \{\mathbf{r}^\alpha_{/j}\}; \{\mathbf{r}^{\bar{\alpha}}\}\big)
&= \left(\mathbf{w}^{k\alpha}_i \cdot \mathbf{h}^{L\alpha}_j + g^{k\alpha}_i\right) \\
\times & \sum_{m} \pi^{k\alpha}_{im}
\exp\Big(
- \big|\mathbf{\Sigma}_{im}^{k\alpha} \big(\mathbf{r}^{\alpha}_j - \mathbf{R}_m\big)\big|
\Big)
\end{aligned}
\]
Here  \(\mathbf{w}^{k\alpha}_i\) and \(g^{k\alpha}_i\) are
learnable linear parameters for the ``MLP part'' of the orbital, the
sum over \(m\) is an ``envelope'' over nuclei (or centers),
\(\pi^{k\alpha}_{im}\) and \(\mathbf{\Sigma}^{k\alpha}_{im}\) are
learnable coefficients and matrices controlling the exponential decay
around nucleus \(m\).

All these parameters depend on the indices: \(k\) selects which
determinant in the sum, \(i\) selects which orbital (row in the
determinant), \(\alpha\) selects the spin sector, \(m\) selects
which nuclear center in the envelope.

The dependence on all other electrons is hidden inside
\(\mathbf{h}^{L\alpha}_j\), which was built from the full set of
positions \(\{\mathbf{r}^\uparrow\},\{\mathbf{r}^\downarrow\}\) through
the deep network.


\subsubsection{Assembling the spin-separated
determinants}\label{assembling-the-spin-separated-determinants-1}

For each determinant index \(k\) and spin sector
\(\alpha\in\{\uparrow,\downarrow\}\), we build a matrix \[
D^{k\alpha}_{ij}
= \phi^{k\alpha}_i\big( \mathbf{r}^\alpha_j; \{\mathbf{r}^\alpha_{/j}\}; \{\mathbf{r}^{\bar{\alpha}}\}\big),
\] with rows indexed by the orbital label \(i = 1,\dots,n^\alpha\),
columns indexed by the electron label \(j = 1,\dots,n^\alpha\) (with
that spin).

Taking the determinant gives a properly antisymmetric function of the
positions of electrons \textbf{with that spin}: \[
\det\big[D^{k\alpha}\big]
= \det\left[\phi^{k\alpha}_i(\mathbf{r}^\alpha_j; \{\mathbf{r}^\alpha_{/j}\}; \{\mathbf{r}^{\bar{\alpha}}\})\right].
\]

For the full wavefunction, we combine spin-up and spin-down blocks:
\begin{align}
\psi(\mathbf{r}^\uparrow_1,\ldots,\mathbf{r}^\uparrow_{n^\uparrow},
     \mathbf{r}^\downarrow_1,\ldots,\mathbf{r}^\downarrow_{n^\downarrow})
=\ \sum_{k} \omega_k [{D}^{k\downarrow}][{D}^{k\uparrow}]
\end{align}
We have don't explained why we can write the determinant as that
product. In electronic structure, when we separate spin and spatial
parts using spin-orbitals, the full Slater determinant over all
electrons factorizes into the product of: one determinant involving only
spin-up electrons, another determinant involving only spin-down
electrons.

Each of these determinants is antisymmetric under exchange of two
electrons \textbf{with the same spin}. The overall wavefunction
constructed as the product of a spin-up determinant and a spin-down
determinant is antisymmetric under exchange of any two electrons (when you take into account the spin labels). FermiNet keeps this structure and lets each block be represented by a powerful neural network ansatz for the orbitals.
Up to this point the building blocks are just MLP layers (with residual
connections and special feature mixing), but the careful indexing,
\((i,\alpha)\) for ``which electron/spin'', \(j\) for summation over
electrons, \(\ell\) for layers, \(k\) for determinant index, is what
guarantees that the final object has the correct permutation symmetry
and antisymmetry required for a fermionic wavefunction.



\subsection{Applying Attention to Fermi Net
(Psiformer-style)}\label{applying-attention-to-fermi-net-psiformer-style}

\subsubsection{Jastrow Factor for Psi
Former}\label{jastrow-factor-for-psi-former}
The Psiformer wavefunction has the usual Slater-Jastrow ansatz  \cite{foulkes2001quantum}:

\begin{equation}
\Psi_{\theta}(\mathbf{x}) = \exp\big(\mathcal{J}_{\theta}(\mathbf{x})\big)\sum_{k=1}^{N_{\det}}\det[\boldsymbol{\Phi}^{k}_{\theta}(\mathbf{x})]
\end{equation}
where \(\mathbf{x} = (x_1,\dots,x_N)\) is the collection of all \(N\)
electron states $x_i = (\mathbf{r}_i,\sigma_i), \mathbf{r}_i \in \mathbb{R}^3,\;\sigma_i \in \{\uparrow,\downarrow\}$,
\(\mathcal{J}_\theta:(\mathbb{R}^{3}\times \{\uparrow,\downarrow\})^{N}\to \mathbb{R}\)
  is the \textbf{Jastrow factor}, encoding (here) only
  electron--electron cusp information. And \(\boldsymbol{\Phi}^k_\theta\) is the matrix of (spin-)orbitals for determinant \(k\).
In Psiformer, the Jastrow factor is \emph{very} simple: it has only two
learnable parameters, one for parallel-spin pairs and one for
antiparallel-spin pairs:
\begin{align}
\mathcal{J}_{\theta}(\mathbf{x})
=
\sum_{i<j;\,\sigma_{i}=\sigma_{j}}
-\frac{1}{4}\frac{\alpha^{2}_{\mathrm{par}}}{\alpha_{\mathrm{par}}+\lvert \mathbf{r}_{i}-\mathbf{r}_{j} \rvert }
+ \notag \\
\sum_{i,j;\,\sigma_{i}\neq \sigma_{j}}
-\frac{1}{2}\frac{\alpha^{2}_{\mathrm{anti}}}{\alpha_{\mathrm{anti}}+\lvert \mathbf{r}_{i}-\mathbf{r}_{j} \rvert }.
\end{align}
Where \(\alpha_{\mathrm{par}}\) controls the strength of the Jastrow for \textbf{same-spin} electron pairs and \(\alpha_{\mathrm{anti}}\) does the same for \textbf{opposite-spin}
  pairs.

This Jastrow is responsible for enforcing the electron--electron cusp
conditions. The neural network itself (the Psiformer) only sees
\textbf{electron--nucleus} information in its attention stream; all
explicit \(|\mathbf{r}_i-\mathbf{r}_j|\) dependence lives in
\(\mathcal{J}_\theta\).


Conceptually as shown on \cref{fig:psif}, Psiformer is ``FermiNet with the two-electron stream
replaced by self-attention''. It only uses \textbf{electron--nuclear} features (plus spin) as
input to the attention stack. For each electron \(i\): 1. Let
\(\mathbf{R}_I\) be nuclear positions. 2. Build raw features by
concatenating for all \(I\):  some function of
\(\mathbf{r}_i  \mathbf{R}_I\) (relative position),
\(|\mathbf{r}_i - \mathbf{R}_I|\) (distance),  and the spin as a scalar
(e.g.~\(\sigma_i = +1\) for \(\uparrow\), \(-1\) for \(\downarrow\)).

In the paper they rescale the electron--nucleus vectors so that large
distances grow only logarithmically \cite{vonglehn2023selfattentionansatzabinitioquantum}, but at the level of notation we can
just write \[
\mathbf{f}_i^{0} \in \mathbb{R}^{d_{\text{in}}}
\quad\text{(electron–nucleus features + spin)}.
\] These are then mapped into the model hidden dimension by a linear
layer \[
\mathbf{h}_{i}^{0} = \mathbf{W}^{0}\,\mathbf{f}_{i}^{0},
\] where \(\mathbf{W}^0 \in \mathbb{R}^{d \times d_{\text{in}}}\) is
learned. So:  index \(i\) is ``which electron'',  superscript \(0\)
means ``before any attention layers.''

At layer \(\ell\), we have all electron hidden states \[
\mathbf{h}_1^{\ell},\dots,\mathbf{h}_N^{\ell}.
\]

For each \textbf{head} \(h\) and electron \(i\), we compute:

\begin{itemize}
\item
  Query: \[
  \mathbf{q}^{\ell h}_i = \mathbf{W}^{\ell h}_q \mathbf{h}^{\ell}_i
  \]
\item
  Key: \[
  \mathbf{k}^{\ell h}_i = \mathbf{W}^{\ell h}_k \mathbf{h}^{\ell}_i
  \]
\item
  Value: \[
  \mathbf{v}^{\ell h}_i = \mathbf{W}^{\ell h}_v \mathbf{h}^{\ell}_i
  \]
\end{itemize}

Here each
\(\mathbf{W}^{\ell h}_q,\mathbf{W}^{\ell h}_k,\mathbf{W}^{\ell h}_v\) is
a learned matrix, shared across all electrons \(i\), but specific to
layer \(\ell\) and head \(h\).

Then the \textbf{self-attention output for electron \(i\), head \(h\)}
is \[
\mathbf{A}^{\ell h}_i
=
\sum_{j=1}^{N}
\underbrace{
\frac{\exp\big((\mathbf{q}^{\ell h}_i)^{\mathsf T}\mathbf{k}^{\ell h}_j / \sqrt{d_k}\big)}
     {\sum_{j'=1}^N \exp\big((\mathbf{q}^{\ell h}_i)^{\mathsf T}\mathbf{k}^{\ell h}_{j'} / \sqrt{d_k}\big)}
}_{\text{attention weight from } i \text{ to } j}
\mathbf{v}^{\ell h}_j.
\]

\begin{itemize}
\item
  \(j\) runs over ``all other electrons,'' so electron \(i\) ``looks''
  at all others via attention.
\item
  \(d_k\) is the key/query dimension (usually \(d_k = d/H\) or similar).
\end{itemize}

This is exactly your \[
A^{\ell}_{h} = [\text{SelfAttn}(\mathbf{h}_1^\ell,\dots,\mathbf{h}_N^\ell;\mathbf{W}^{\ell h}_q,\mathbf{W}^{\ell h}_k,\mathbf{W}^{\ell h}_v)],
\] but now written explicitly with indices \(i\) and \(j\).

Next, we \textbf{concatenate over heads} for each electron: \[
\mathbf{A}^{\ell}_i = \text{concat}_{h=1}^H\big[\mathbf{A}^{\ell h}_i\big]
\in \mathbb{R}^{Hd_v},
\] where \(d_v\) is the value dimension of each head.


\subsubsection{Residual projection and
MLP}\label{residual-projection-and-mlp}

We then map the concatenated attention output back to the hidden
dimension and add a residual connection: \[
\mathbf{f}_{i}^{\ell+1}
=
\mathbf{h}_{i}^{\ell}
+
\mathbf{W}_{o}^{\ell}\,\mathbf{A}^{\ell}_i,
\] where \(\mathbf{W}_{o}^{\ell}\) is a learned matrix.

Then we pass this through a small MLP,
again with a residual: \[
\mathbf{h}_{i}^{\ell+1}
=
\mathbf{f}_{i}^{\ell+1}
+
\tanh\big(\mathbf{W}^{\ell+1}\mathbf{f}_{i}^{\ell+1} + \mathbf{b}^{\ell+1}\big).
\]
So a full Psiformer layer \(\ell\) is:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Self-attention: \(\{\mathbf{h}_i^\ell\} \to \{\mathbf{A}^\ell_i\}\).
\item
  Linear + residual:
  \(\{\mathbf{A}^\ell_i\} \to \{\mathbf{f}_i^{\ell+1}\}\).
\item
  MLP + residual:
  \(\{\mathbf{f}_i^{\ell+1}\} \to \{\mathbf{h}_i^{\ell+1}\}\).
\end{enumerate}

Repeat this for \(\ell=0,\dots,L-1\) and you get \textbf{final hidden
states} $
\mathbf{h}_j^{L} \text{ for each electron } j$


\subsubsection{From hidden states to orbitals and
determinants}\label{from-hidden-states-to-orbitals-and-determinants}

From the final hidden states \(\mathbf{h}_j^L\), we build the
spin-orbital matrix for each determinant \(k\).

For each determinant index \(k\) and orbital index \(i\), define a
\textbf{linear ``orbital head''}: \[
\tilde{\phi}^{k}_i(x_j)
=
\mathbf{w}^{k}_i \cdot \mathbf{h}^{L}_j
+
g^{k}_i,
\] where \(\mathbf{w}^{k}_i\) and \(g^{k}_i\) are learned. The
dependence on spin \(\sigma_j\) and all other electrons is implicit in
\(\mathbf{h}_j^L\): the self-attention layers have already mixed that
information in.

Then we multiply by an \textbf{envelope} to enforce the correct
asymptotic decay: \[
\Omega^{k}_{ij}
=
\sum_{m}
\pi^{k}_{im}
\exp\big(
- \big|\mathbf{\Sigma}^{k}_{im}(\mathbf{r}_j - \mathbf{R}_m)\big|
\big),
\] where \(m\) indexes nuclei (or ``envelope centers''),
\(\pi^{k}_{im}\) and \(\mathbf{\Sigma}^{k}_{im}\) are learned
parameters.
The final spin-orbital entries are \[
\Phi^{k}_{ij}
=
\Omega^{k}_{ij}\,
\tilde{\phi}^{k}_i(x_j).
\]
Collecting these into the matrix \[
\boldsymbol{\Phi}^k(\mathbf{x}) =
\big[\Phi^{k}_{ij}\big]_{i,j=1}^N,
\] we form the determinant \[
\det[\boldsymbol{\Phi}^k(\mathbf{x})]
=
\det\big[\Phi^{k}_{ij}\big]
=
\det\big[\phi^{k}_i(x_j)\big],
\] and finally the full Psiformer wavefunction \[
\Psi_{\theta}(\mathbf{x})
=
\exp(\mathcal{J}_{\theta}(\mathbf{x}))
\sum_{k=1}^{N_{\det}}\det[\boldsymbol{\Phi}^{k}_{\theta}(\mathbf{x})].
\]
The self-attention layers are what let \(\mathbf{h}_j^L\) depend on all
other electrons in a flexible, learned way, while the determinant over
\(i,j\) and the Jastrow over \(i,j\) enforce fermionic antisymmetry and
cusp conditions.



\section{Methodology}\label{methodology}


The implementation of PsiFormer requires a computational framework capable of expressing flexible neural architectures while remaining efficient on large-scale parallel hardware. Modern deep-learning ecosystems offer several possibilities, most notably JAX, TensorFlow, and PyTorch. Each provides automatic differentiation and GPU/TPU support. PyTorch, widely adopted across research domains, offers a dynamic computation graph and a rich ecosystem of scientific tooling. Prior work in variational Monte Carlo, including FermiNet, has motivated similar design principles, although its original implementation relied on TensorFlow \cite{Paszke2019PyTorch, vonglehn2023selfattentionansatzabinitioquantum, Pfau_2020}. Given the broader community support, debugging simplicity, and availability of open-source implementations of attention-based architectures, PyTorch is chosen as the primary framework.

Additionally, the HuggingFace Transformers library \cite{wolfetal2020transformers} provides a modular reference for attention layers, layer norms, initialization schemes, and efficient training utilities.


Training models in the PsiFormer family requires significant computational resources, as reported by the original authors. Electronic-structure wavefunctions demand repeated sampling, expensive determinant evaluations, and long optimization horizons, pushing typical training times into several days or weeks depending on molecular complexity.

To address these requirements, we rely on GPU-accelerated environments with CUDA support. While cloud notebook platforms such as Google Colab offer accessible GPUs, their instability, session limits, and restricted runtimes make them unsuitable for long-range experiments. Instead, the project uses rented GPU instances (e.g., RunPod or comparable providers).

\bibliographystyle{unsrt}
\bibliography{refs1}


\end{document}
